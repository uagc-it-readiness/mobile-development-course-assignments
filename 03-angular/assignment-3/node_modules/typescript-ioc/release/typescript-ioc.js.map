{"version":3,"sources":["../src/typescript-ioc.ts"],"names":[],"mappings":"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","file":"typescript-ioc.js","sourcesContent":["\"use strict\";\n/**\n * This is a lightweight annotation-based dependency injection container for typescript.\n *\n * Visit the project page on [GitHub] (https://github.com/thiagobustamante/typescript-ioc).\n */\n\nimport \"reflect-metadata\"\n\n/**\n * A decorator to tell the container that this class should be handled by the Singleton [[Scope]].\n *\n * ```\n * @ Singleton\n * class PersonDAO {\n *\n * }\n * ```\n *\n * Is the same that use:\n *\n * ```\n * Container.bind(PersonDAO).scope(Scope.Singleton)\n * ```\n */\nexport function Singleton(target: Function) {\n    IoCContainer.bind(target).scope(Scope.Singleton);\n}\n\n/**\n * A decorator to tell the container that this class should be handled by the provided [[Scope]].\n * For example:\n *\n * ```\n * class MyScope extends Scope {\n *   resolve(iocProvider:Provider, source:Function) {\n *     console.log('created by my custom scope.')\n *     return iocProvider.get();\n *   }\n * }\n * @ Scoped(new MyScope())\n * class PersonDAO {\n * }\n * ```\n *\n * Is the same that use:\n *\n * ```\n * Container.bind(PersonDAO).scope(new MyScope());\n * ```\n * @param scope The scope that will handle instantiations for this class.\n */\nexport function Scoped(scope: Scope) {\n    return function(target: Function) {\n        IoCContainer.bind(target).scope(scope);\n    }\n}\n\n/**\n * A decorator to tell the container that this class should instantiated by the given [[Provider]].\n * For example:\n *\n * ```\n * @ Provided({get: () => { return new PersonDAO(); }})\n * class PersonDAO {\n * }\n * ```\n *\n * Is the same that use:\n *\n * ```\n * Container.bind(PersonDAO).provider({get: () => { return new PersonDAO(); }});\n * ```\n * @param provider The provider that will handle instantiations for this class.\n */\nexport function Provided(provider: Provider) {\n    return function(target: Function) {\n        IoCContainer.bind(target).provider(provider);\n    }\n}\n\n/**\n * A decorator to tell the container that this class should be used as the implementation for a given base class.\n * For example:\n *\n * ```\n * class PersonDAO {\n * }\n *\n * @ Provides(PersonDAO)\n * class ProgrammerDAO extends PersonDAO{\n * }\n * ```\n *\n * Is the same that use:\n *\n * ```\n * Container.bind(PersonDAO).to(ProgrammerDAO);\n * ```\n * @param target The base class that will be replaced by this class.\n */\nexport function Provides(target: Function) {\n    return function(to: Function) {\n        IoCContainer.bind(target).to(to);\n    }\n}\n\n/**\n * A decorator to tell the container that this class should its instantiation always handled by the Container.\n *\n * An AutoWired class will have its constructor overriden to always delegate its instantiation to the IoC Container.\n * So, if you write:\n *\n * ```\n * @ AutoWired\n * class PersonService {\n *   @ Inject\n *   personDAO: PersonDAO;\n * }\n * ```\n *\n * Any PersonService instance will be created by the IoC Container, even when a direct call to its constructor is called:\n *\n * ```\n * let PersonService = new PersonService(); // will be returned by Container, and all internal dependencies resolved.\n * ```\n *\n * It is the same that use:\n *\n * ```\n * Container.bind(PersonService);\n * let personService: PersonService = Container.get(PersonService);\n * ```\n */\nexport function AutoWired(target: Function) {\n    let existingInjectedParameters: number[] =\n        Reflect.getOwnMetadata(\"params_inject\", target) || [];\n    let newConstructor;\n    if (existingInjectedParameters.length > 0) {\n        existingInjectedParameters.reverse();\n        const paramTypes: Array<any> =\n            Reflect.getMetadata(\"design:paramtypes\", target);\n        newConstructor = InjectorHanlder.decorateConstructor(function(...args: any[]) {\n            IoCContainer.assertInstantiable(target);\n            let newArgs: Array<any> = args ? args.concat() : new Array<any>();\n            for (let index of existingInjectedParameters) {\n                if (index >= newArgs.length) {\n                    newArgs.push(IoCContainer.get(paramTypes[index]));\n                }\n            }\n            IoCContainer.applyInjections(this, target);\n            target.apply(this, newArgs);\n        }, target);\n    }\n    else {\n        newConstructor = InjectorHanlder.decorateConstructor(function(...args: any[]) {\n            IoCContainer.assertInstantiable(target);\n            IoCContainer.applyInjections(this, target);\n            target.apply(this, args);\n        }, target);\n    }\n    let config: ConfigImpl = <ConfigImpl>IoCContainer.bind(target)\n    config.toConstructor(newConstructor);\n    return newConstructor;\n}\n\n/**\n * A decorator to request from Container that it resolve the annotated property dependency.\n * For example:\n *\n * ```\n * @ AutoWired\n * class PersonService {\n *    constructor (@ Inject creationTime: Date) {\n *       this.creationTime = creationTime;\n *    }    \n *    @ Inject\n *    personDAO: PersonDAO;\n *\n *    creationTime: Date;\n * }\n *\n * ```\n *\n * When you call:\n *\n * ```\n * let personService: PersonService = Container.get(PersonService);\n * // The properties are all defined, retrieved from the IoC Container\n * console.log('PersonService.creationTime: ' + personService.creationTime); \n * console.log('PersonService.personDAO: ' + personService.personDAO); \n * ```\n */\nexport function Inject(...args: any[]) {\n    if (args.length < 3 || typeof args[2] === \"undefined\") {\n        return InjectPropertyDecorator.apply(this, args);\n    }\n    else if (args.length == 3 && typeof args[2] === \"number\") {\n        return InjectParamDecorator.apply(this, args);\n    }\n\n    throw new Error(\"Invalid @Inject Decorator declaration.\");\n}\n\n/**\n * Decorator processor for [[Inject]] decorator on properties\n */\nfunction InjectPropertyDecorator(target: Object, key: string) {\n    let t = Reflect.getMetadata(\"design:type\", target, key);\n    IoCContainer.addPropertyInjector(target.constructor, key, t);\n}\n\n/**\n * Decorator processor for [[Inject]] decorator on constructor parameters\n */\nfunction InjectParamDecorator(target: Object, propertyKey: string | symbol,\n    parameterIndex: number) {\n    if (!propertyKey) // only intercept constructor parameters\n    {\n        let existingInjectedParameters: number[] =\n            Reflect.getOwnMetadata(\"params_inject\", target, propertyKey) || [];\n        existingInjectedParameters.push(parameterIndex);\n        Reflect.defineMetadata(\"params_inject\", existingInjectedParameters,\n            target, propertyKey);\n    }\n}\n\n/**\n * The IoC Container class. Can be used to register and to retrieve your dependencies.\n * You can also use de decorators [[AutoWired]], [[Scoped]], [[Singleton]], [[Provided]] and [[Provides]]\n * to configure the dependency directly on the class.\n */\nexport class Container {\n    /**\n     * Add a dependency to the Container. If this type is already present, just return its associated \n     * configuration object.\n     * Example of usage:\n     *\n     * ```\n     * Container.bind(PersonDAO).to(ProgrammerDAO).scope(Scope.Singleton);\n     * ```\n     * @param source The type that will be bound to the Container\n     * @return a container configuration\n     */\n    static bind(source: Function): Config {\n        if (!IoCContainer.isBound(source))\n        {\n            AutoWired(source);\n            return IoCContainer.bind(source).to(source);\n        }\n\n        return IoCContainer.bind(source);\n    }\n\n    /**\n     * Retrieve an object from the container. It will resolve all dependencies and apply any type replacement\n     * before return the object.\n     * If there is no declared dependency to the given source type, an implicity bind is performed to this type.\n     * @param source The dependency type to resolve\n     * @return an object resolved for the given source type;\n     */\n    static get(source: Function) {\n        return IoCContainer.get(source);\n    }\n}\n\n/**\n * Internal implementation of IoC Container.\n */\nclass IoCContainer {\n    private static bindings: Map<FunctionConstructor,ConfigImpl> = new Map<FunctionConstructor,ConfigImpl>();\n\n    static isBound(source: Function): boolean\n    {\n        checkType(source);\n        const baseSource = InjectorHanlder.getConstructorFromType(source);\n        let config: ConfigImpl = IoCContainer.bindings.get(baseSource);\n        return (!!config);\n    }\n\n    static bind(source: Function): Config {\n        checkType(source);\n        const baseSource = InjectorHanlder.getConstructorFromType(source);\n        let config: ConfigImpl = IoCContainer.bindings.get(baseSource);\n        if (!config) {\n            config = new ConfigImpl(baseSource);\n            IoCContainer.bindings.set(baseSource, config);\n        }\n        return config;\n    }\n\n    static get(source: Function) {\n        let config: ConfigImpl = <ConfigImpl>IoCContainer.bind(source);\n        if (!config.iocprovider) {\n            config.to(<FunctionConstructor>config.source);\n        }\n        return config.getInstance();\n    }\n\n    static applyInjections(toInject: Object, targetType?: Function) {\n        if (targetType) {\n            const injections: Array<any> = InjectorHanlder.getInjectorFromType(targetType, false);\n            injections.forEach(entry => {\n                entry(toInject);\n            });\n        }\n        else {\n            const injections: Array<any> = InjectorHanlder.getInjectorFromInstance(toInject);\n            injections.forEach(entry => {\n                entry(toInject);\n            });\n        }\n    }\n\n    static addPropertyInjector(target: Function, key: string, propertyType: Function) {\n        const injections: Array<any> = InjectorHanlder.getInjectorFromType(target, false);\n        injections.push(toInject => {\n            IoCContainer.injectProperty(toInject, key, propertyType);\n        });\n    }\n\n    static injectProperty(toInject: Object, key: string, source: Function) {\n        toInject[key] = IoCContainer.get(source);\n    }\n\n    static assertInstantiable(target: Function) {\n        if (target['__block_Instantiation']) {\n            throw new TypeError(\"Can not instantiate Singleton class. \" +\n                \"Ask Container for it, using Container.get\");\n        }\n    }\n}\n\n/**\n * Utility function to validate type\n */\nfunction checkType(source: Object) {\n    if (!source) {\n        throw new TypeError('Invalid type requested to IoC ' +\n            'container. Type is not defined.');\n    }\n}\n\n/**\n * A bind configuration for a given type in the IoC Container.\n */\nexport interface Config {\n    /**\n     * Inform a given implementation type to be used when a dependency for the source type is requested.\n     * @param target The implementation type\n     */\n    to(target: Object): Config;\n    /**\n     * Inform a provider to be used to create instances when a dependency for the source type is requested.\n     * @param provider The provider to create instances\n     */\n    provider(provider: Provider): Config;\n    /**\n     * Inform a scope to handle the instances for objects created by the Container for this binding.\n     * @param scope Scope to handle instances\n     */\n    scope(scope: Scope): Config;\n}\n\nclass ConfigImpl implements Config {\n    source: Function;\n    iocprovider: Provider;\n    iocscope: Scope;\n    decoratedConstructor: FunctionConstructor;\n\n    constructor(source: Function) {\n        this.source = source;\n    }\n\n    to(target: FunctionConstructor) {\n        checkType(target);\n        const targetSource = InjectorHanlder.getConstructorFromType(target);\n        if (this.source === targetSource) {\n            const _this = this;\n            this.iocprovider = {\n                get: () => {\n                    if (_this.decoratedConstructor) {\n                        return new _this.decoratedConstructor();\n                    }\n                    return new target();\n                }\n            };\n        }\n        else {\n            this.iocprovider = {\n                get: () => {\n                    return IoCContainer.get(target);\n                }\n            };\n        }\n        if (this.iocscope) {\n            this.iocscope.reset(this.source);\n        }\n        return this;\n    }\n\n    provider(provider: Provider) {\n        this.iocprovider = provider;\n        if (this.iocscope) {\n            this.iocscope.reset(this.source);\n        }\n        return this;\n    }\n\n    scope(scope: Scope) {\n        this.iocscope = scope;\n        if (scope === Scope.Singleton) {\n            this.source['__block_Instantiation'] = true;\n            scope.reset(this.source);\n        }\n        else if (this.source['__block_Instantiation']) {\n            delete this.source['__block_Instantiation'];\n        }\n        return this;\n    }\n\n    toConstructor(newConstructor: FunctionConstructor) {\n        this.decoratedConstructor = newConstructor;\n        return this;\n    }\n\n    getInstance() {\n        if (!this.iocscope) {\n            this.scope(Scope.Local);\n        }\n        return this.iocscope.resolve(this.iocprovider, this.source);\n    }\n}\n\n/**\n * A factory for instances created by the Container. Called every time an instance is needed.\n */\nexport interface Provider {\n    /** \n     * Factory method, that should create the bind instance.\n     * @return the instance to be used by the Container\n     */\n    get(): Object;\n}\n\n/**\n * Class responsible to handle the scope of the instances created by the Container\n */\nexport abstract class Scope {\n    /**\n     * A reference to the LocalScope. Local Scope return a new instance for each dependency resolution requested.\n     * This is the default scope.\n     */\n    static Local: Scope;\n    /**\n     * A reference to the SingletonScope. Singleton Scope return the same instance for any \n     * dependency resolution requested.\n     */\n    static Singleton: Scope;\n\n    /**\n     * Method called when the Container needs to resolve a dependency. It should return the instance that will\n     * be returned by the Container.\n     * @param provider The provider associated with the current bind. Used to create new instances when necessary.\n     * @param source The source type of this bind.\n     * @return the resolved instance.\n     */\n    abstract resolve(provider: Provider, source: Function): any;\n\n    /**\n     * Called by the IoC Container when some configuration is changed on the Container binding.\n     * @param source The source type that has its configuration changed.\n     */\n    reset(source: Function) {\n\n    }\n}\n\n/**\n * Default [[Scope]] that always create a new instace for any dependency resolution request\n */\nclass LocalScope extends Scope {\n    resolve(provider: Provider, source: Function) {\n        return provider.get();\n    }\n}\n\nScope.Local = new LocalScope();\n\n/**\n * Scope that create only a single instace to handle all dependency resolution requests.\n */\nclass SingletonScope extends Scope {\n    private static instances: Map<Function,any> = new Map<Function,any>();\n\n    resolve(provider: Provider, source: Function) {\n        let instance: any = SingletonScope.instances.get(source);\n        if (!instance) {\n            source['__block_Instantiation'] = false;\n            instance = provider.get();\n            source['__block_Instantiation'] = true;\n            SingletonScope.instances.set(source, instance);\n        }\n        return instance;\n    }\n\n    reset(source: Function) {\n        SingletonScope.instances.delete(InjectorHanlder.getConstructorFromType(source));\n    }\n}\n\nScope.Singleton = new SingletonScope();\n\n\n/**\n * Utility class to handle injection behavior on class decorations.\n */\nclass InjectorHanlder {\n    static typeInjections: Map<string,Array<any>> = new Map<string,Array<any>>();\n\n    static decorateConstructor(derived: Function, base: Function) {\n        for (var p in base) {\n            if (base.hasOwnProperty(p) && !derived.hasOwnProperty(p)) {\n                derived[p] = base[p];\n            }\n        }\n        derived['__parent'] = base;\n        function __() { this.constructor = derived; }\n        derived.prototype = base === null ? Object.create(base) :\n            (__.prototype = base.prototype, new __());\n        return derived;\n    }\n\n    static getConstructorFromType(target: Function): FunctionConstructor {\n        let typeConstructor: Function = target;\n        if (typeConstructor['name']) {\n            return <FunctionConstructor>typeConstructor;\n        }\n        while (typeConstructor = typeConstructor['__parent']) {\n            if (typeConstructor['name']) {\n                return <FunctionConstructor>typeConstructor;\n            }\n        }\n        throw TypeError('Can not identify the base Type for requested target');\n    }\n\n    static getConstructorFromInstance(target: Object): FunctionConstructor {\n        return InjectorHanlder.getConstructorFromType(target.constructor);\n    }\n    static getInjectorFromType(target: Function, recursive: boolean) {\n        const baseConstructor: Object = InjectorHanlder.getConstructorFromType(target);\n        if (!InjectorHanlder.typeInjections[<any>baseConstructor]) {\n            InjectorHanlder.typeInjections[<any>baseConstructor] = new Array<any>();\n        }\n        let result: Array<any> = InjectorHanlder.typeInjections[<any>baseConstructor];\n        if (recursive) {\n            let parent: Function = baseConstructor['__parent'];\n            if (parent) {\n                result = InjectorHanlder.getInjectorFromType(parent, true).concat(result);\n            }\n        }\n        return result;\n    }\n\n    static getInjectorFromInstance(target: Object) {\n        const baseConstructor: Function = InjectorHanlder.getConstructorFromInstance(target);\n        return InjectorHanlder.getInjectorFromType(baseConstructor, true)\n    }\n}\n\ninterface Map<K, V> {\n    clear(): void;\n    delete(key: K): boolean;\n    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;\n    get(key: K): V | undefined;\n    has(key: K): boolean;\n    set(key: K, value?: V): this;\n    readonly size: number;\n}\n\ninterface MapConstructor {\n    new (): Map<any, any>;\n    new <K, V>(entries?: [K, V][]): Map<K, V>;\n    readonly prototype: Map<any, any>;\n}\ndeclare var Map: MapConstructor;\n"]}